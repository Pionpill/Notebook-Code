\section{原型链}

原型链有三个关键的概念: 对象，构造函数，原型(原型本身也是一个对象)。它们之间的关系如下:
\begin{itemize}
  \item 构造函数的的 \texttt{prototype} 属性指向原型。
  \item 构造函数通过 \texttt{new} 创建对象。
  \item 对象的 \texttt{\_\_proto\_\_} 属性指向原型。
  \item 原型的 \texttt{constructor} 属性指向对应的构造函数。
  \item 原型本身也是对象，因此原型也有一个 \texttt{\_\_proto\_\_} 属性指向原型的原型。如果为 \texttt{null}，则说明是 \texttt{Object} 对象。
\end{itemize}

\subsection{\texttt{new} 过程}

假设有如下代码:

\begin{JavaScript}
const Mother = function (name) {
  this.name = name;
}
var son = new Mother("pionpill");
\end{JavaScript}

通过 \texttt{new} 关键字创建对象会发生如下过程:
\begin{itemize}
  \item 创建一个新的空对象 \texttt{son}。
  \item 新对象的原型被绑定起来:
\begin{JavaScript}
son.__proto__ = Mother.prototype;
\end{JavaScript}
\item 新对象和函数调用的 \texttt{this} 会绑定起来:
\begin{JavaScript}
Mother.call(son,"pionpill")
\end{JavaScript}
  \item 执行构造函数中的代码;
  \item 如果没有返回值，则自动返回这个新对象。
\end{itemize}

注意，在 JavaScript 中，普通函数和构造函数没有任何区别(写法上，我们习惯将构造函数使用大驼峰写法)。如果是通过 \texttt{new} 创建，则会自动返回新对象，但如果不是，则执行普通函数的逻辑，不进行原型绑定，\texttt{this} 绑定，返回新对象等操作。

此外，如果 \texttt{new} 构造函数，且构造函数中有返回值。假如返回值是基本类型，没有什么影响，\texttt{new} 的时候直接忽视，只对非 \texttt{new} 有影响。如果返回引用类型，那么返回的引用类型会替代原来的返回值。

\subsection{手写 \texttt{new}}

\begin{JavaScript}
const customNew = (func, ...args) => {
  if (typeof func !== "function") return null;
  const newObj = Object.create(func.prototype);
  const result = func.apply(newObj, args);
  return typeof result === "object" ? result : newObj;
};
\end{JavaScript}