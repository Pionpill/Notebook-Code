\section{深拷贝}

首先明确一点，JS 的简单类型放在栈中，只有深拷贝，即复制一份。引用类型在堆中，默认进行浅拷贝，这是深拷贝需要解决的主要问题。

这里只讲自定义函数实现深拷贝，固有的 \texttt{JSON.parse(JSON.stringify(obj))} 以及一些其他方法具有很多缺陷，这里不作说明:

首先我们需要判断数据类型是不是对象:

\begin{JavaScript}
const isObject = (obj) => {
  return (obj !== null && (typeof obj === 'object' || typeof obj === 'function'));
}
\end{JavaScript}

然后我们实现基本功能:

\begin{JavaScript}
const deepClone = (obj) => {
  if (!isObject(obj))
    return obj;
  const newObj = {};
  // 基本类深拷贝
  newObj = Object.assign(obj);
  for (const key of obj) {
    deepClone(obj[key]);
  }
}
\end{JavaScript}

针对常见的不同类型，需要单独处理:

\begin{JavaScript}
const deepClone = (obj) => {
  if (!isObject(obj))
    return obj;
  if (obj instanceof Array) {
    return obj.concat();
  }
  if (obj instanceof Set) {
    const temp = new Set();
    obj.forEach((item) => {
      temp.add(deepClone(item));
    })
    return obj;
  }
  if (obj instanceof Map) {
    const temp = new Map();
    obj.forEach((item, key) => {
      temp.set(key, deepClone(item));
    })
    return temp;
  }
  if (obj instanceof RegExp) {
    const temp = new RegExp(obj);
    return temp;
  }
  const newObj = {};
  // 基本类深拷贝
  newObj = Object.assign(obj);
  for (const key of obj) {
    deepClone(obj[key]);
  }
}
\end{JavaScript}

其次我们需要解决循环引用问题:

\begin{JavaScript}
const deepClone = (obj) => {
  const isObject = (obj) => {
    return (obj !== null && (typeof obj === 'object' || typeof obj === 'function'));
  }
  
  const map = new WeakMap();

  const copy = (obj) => {
    if (!isObject(obj))
      return obj;
    
    if (map.get(obj))
      return map.get(obj);
    
    if (obj instanceof Array) {
      map.set(obj, obj.concat());
      return obj.concat();
    }
    if (obj instanceof Set) {
      const temp = new Set();
      map.set(obj, temp);
      obj.forEach((item) => {
        temp.add(deepClone(item));
      })
      return obj;
    }
    if (obj instanceof Map) {
      const temp = new Map();
      map.set(obj, temp);
      obj.forEach((item, key) => {
        temp.set(key, deepClone(item));
      })
      return temp;
    }
    if (obj instanceof RegExp) {
      const temp = new RegExp(obj);
      return temp;
    }
    const newObj = {};
    // 基本类深拷贝
    newObj = Object.assign(obj);
    for (const key of obj) {
      copy(obj[key]);
    }
  }
}
\end{JavaScript}

注意，只有容器(集合，列表这些)才会产生循环引用问题。